% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_func.R
\name{predict.ssnbayes2}
\alias{predict.ssnbayes2}
\title{Performs spatio-temporal prediction in R using an ssnbayes object from a fitted model.}
\usage{
\method{predict}{ssnbayes2}(
  object = object,
  ...,
  use_osm_ssn = TRUE,
  osm_ssn = osm_ssn,
  path = path,
  obs_data = obs_data,
  pred_data = pred_data,
  net = net,
  nsamples = nsamples,
  addfunccol = addfunccol,
  locID_pred = locID_pred,
  chunk_size = chunk_size,
  seed = seed
)
}
\arguments{
\item{object}{A stanfit object returned from ssnbayes}

\item{...}{Other parameters}

\item{use_osm_ssn}{Use a supplied osm_ssn instead a SpatialStreamNetwork object.}

\item{osm_ssn}{The osm_ssn to be used.}

\item{path}{If not using an osm_ssn, path with the name of the SpatialStreamNetwork object.}

\item{obs_data}{The observed data frame}

\item{pred_data}{The predicted data frame}

\item{net}{(optional) Network from the SSN object}

\item{nsamples}{The number of samples to draw from the posterior distributions. (nsamples <= iter)}

\item{addfunccol}{If not using an osm_ssn, the variable used for spatial weights}

\item{locID_pred}{(optional) the location id for the predictions. Used when the number of pred locations is large.}

\item{chunk_size}{(optional) the number of locID to make prediction from}

\item{seed}{(optional) A seed for reproducibility}
}
\value{
A data frame with the location (locID), time point (date), plus the MCMC draws from the posterior from 1 to the number of iterations.
The locID0 column is an internal consecutive location ID (locID) produced in the predictions, starting at max(locID(observed data)) + 1. It is used internally in the way predictions are made in chunks.
}
\description{
It will take an observed and a prediction data frame.
It requires the same number of observation/locations per day.
It requires location id (locID) and points id (pid).
The locID are unique for each site.
The pid is unique for each observation.
Missing values are allowed in the response but not in the covariates.
}
\details{
The returned data frame is melted to produce a long dataset. See examples.
}
\examples{
\donttest{
# require('SSNdata')
# require('sf')
#
# clear <- readRDS(system.file("extdata/clear_obs.RDS", package = "SSNdata"))
#
# clear_osm_ssn <- generate_osm_ssn(clear, "long", "lat", root_loc = 12, plot_network = TRUE)
#
# formula = y ~ SLOPE + elev + air_temp + sin + cos
#
# family = "gaussian"
#
# # Note - missing data must be imputed before using the predict() function.
# # This can be done using:
# data_impute <- mtsdi::mnimput(
#   formula = temp ~ SLOPE + elev + h2o_area + air_temp + sin + cos,
#   dataset = clear,
#   eps = 1e-3,
#   ts = FALSE,
#   method = "glm"
# )$filled.dataset
#
# clear <- left_join(clear, data_impute, by = c("elev", "air_temp", "sin", "cos", "SLOPE"))
#
# clear$y <- clear$temp.y
#
# fit_ar <- ssnbayes2(formula = formula,
#                     data = clear,
#                     osm_ssn = clear_osm_ssn,
#                     family = family,
#                     time_method = list("ar", "date"),
#                     space_method = list('use_osm_ssn', c("Exponential.taildown")),
#                     iter = 2000,
#                     warmup = 1000,
#                     chains = 3,
#                     cores = 3)
#
# # Get the coordinate reference system of the near_X and near_Y variables
# data_crs <- system.file("extdata/clearwater.ssn", package = "SSNbayes") \%>\%
#   SSN2::ssn_import(predpts = "preds", overwrite  = TRUE) \%>\%
#   SSN2::ssn_get_data(name = "preds") \%>\%
#   st_crs
#
# # Load in the predictions, and convert to 4326 CRS
# clear_preds <- readRDS(system.file("extdata/clear_preds.RDS", package = "SSNbayes")) \%>\%
#   st_as_sf(coords = c("NEAR_X","NEAR_Y"),
#            crs = data_crs) \%>\%
#   st_transform(crs = 4326)
#
# # Extract the long and lat columns
# xy <- st_coordinates(clear_preds)
#
# colnames(xy) <- c("long", "lat")
#
# Merge back in with the prediction dataset
# clear_preds <- cbind(clear_preds, xy) \%>\%
#   data.frame() \%>\%
#   select(-geometry)
#
# same_names <- intersect(names(clear), names(clear_preds))
#
# # Combine all observed and prediction sites into 1 dataframe
# all_sites <- rbind(clear \%>\% select(same_names),
#                    data.frame(clear_preds) \%>\% select(same_names)
#                    )
#
#
# clear_preds_osm_ssn <- generate_osm_ssn(sensor_data = all_sites,
#                                         lon_name = "long", lat_name = "lat",
#                                         root_loc = 12,
#                                         plot_network = TRUE,
#                                         gen_pred_sites = FALSE)
#
#
#
# locs <- clear_preds_osm_ssn$dist_mat_all$e \%>\% colnames
#
#
# clear_krig <- clear \%>\%
#   filter(locID \%in\% locs)
#
# clear_krig_preds <- clear_preds \%>\%
#   filter(locID \%in\% locs)
#
#
# preds <- predict(object = fit_ar,
#                  use_osm_ssn = TRUE,
#                  osm_ssn = clear_preds_osm_ssn,
#                  obs_data = clear_krig,
#                  pred_data = clear_krig_preds,
#                  seed = seed,
#                  nsamples = 25,
#                  chunk_size = length(unique(clear_krig_preds$locID))
#                  )
#
# # Condense data to posterior point estimates
# ys <- reshape2::melt(preds, id.vars = c('locID0', 'locID', 'date'), value.name ='y')
# ys$iter <- gsub("[^0-9.-]", "", ys$variable)
# ys$variable <- NULL
#
# ys <- data.frame(ys) \%>\% dplyr::group_by(date, locID, locID0) \%>\%
#   dplyr::summarise("sd" = sd(y, na.rm=T),
#                    "y_pred" = mean(y, na.rm=T))
#
# ys <- dplyr::arrange(ys, locID)
#'}
}
\author{
Edgar Santos-Fernandez
}
